---
layout: post
title: Effective OC - 属性
categories: 技术

---

###属性

  使用属性而不是直接声明实例变量的好处是：编译器会自动编写访问这些属性的方法，这个过程叫做“自动合成(autosynthesis)”。需要强调的是，自动合成由编译器在__编译期__完成，所以在编辑器中看不到这些合成方法的源码。除了生成方法之外，编译器还自动向类中添加适当类型的实例变量，斌并且在属性名前面加下划线，以此作为实例变量的名字；若不想使用这种默认规则生成的名字，也可以在类的实现代码中用@synthesize语法来指定实例变量的名字。
  @dynamic关键字的作用是，告诉编译器不要自动创建实现属性所用的实例变量和存取方法。
  
###属性的特质(attribute)

+ 原子性

atomic:原子的，此为默认值，但是并不存在这个写法，不显示声明为nonatomic时就是atomic。

nonatomic:非原子的，属性一般都声明为nonatomic。

+ 读/写权限

readwrite:可读可写，此特质声明的属性拥有获取和设置方法。此是默认值？

readonly:只读，此特质声明的属性仅拥有获取方法。

+ 内存管理语义

assign:简单赋值

strong:强引用，拥有关系，为此特性的属性设置新值时，会先先保留(retain)新值并释放(release)旧值，然后将新值设置上去。

weak:弱引用，非拥有关系，为此特性的属性设置新值时，既不保留新值，也不释放旧值，同assign类似。

copy:强引用，拥有关系，与strong不同的是，它不会保留新值，而是将新值copy一份，同时释放旧值，然后将copy出来的值设置上去。

+ 方法名

getter=<getterName>:指定获取方法的名称，默认的获取方法名就是属性的名称，但是这对部分人来说，如果属性是BOOL类型时，前缀是is的获取方法看起来更顺眼，就可以用此种方式来指定获取方法。

setter=<setterName>:指定设置方法的名称，基本不常见。


通过以上特质，可以定制编译器自动合成的方法。不过需要注意的是：若自己来实现存取方法，那么应该保证实现逻辑符合属性声明的相关特质。比方说，属性声明为copy特质的，那么就应该在setter方法中拷贝相关对象，否则会误导该属性的使用者，还会产生BUG。



